{
  "name": "extender",
  "version": "0.0.9",
  "description": "Easily create object decorators!",
  "main": "index.js",
  "scripts": {
    "test": "it -r dotmatrix"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:doug-martin/extender.git"
  },
  "keywords": [
    "decorator",
    "extend",
    "extender",
    "chain",
    "wrap"
  ],
  "author": {
    "name": "Doug Martin",
    "url": "blog.dougamartin.com"
  },
  "license": "MIT",
  "testling": {
    "files": "test/browserling.js",
    "browsers": [
      "ie/8..latest",
      "chrome/20..latest",
      "firefox/14..latest",
      "safari/latest",
      "iphone/6",
      "ipad/6"
    ]
  },
  "dependencies": {
    "declare.js": "~0.0.4",
    "grunt": "~0.4.1"
  },
  "devDependencies": {
    "it": "~0.2.0",
    "grunt-it": "~0.3.0",
    "grunt-contrib-uglify": "~0.2.0",
    "grunt-contrib-jshint": "~0.4.3"
  },
  "readme": "<a name=\"top\"></a>\n\n\n[![build status](https://secure.travis-ci.org/doug-martin/extender.png)](https://travis-ci.org/doug-martin/extender)\n\n[![browser support](https://ci.testling.com/doug-martin/extender.png)](https://ci.testling.com/doug-martin/extender)\n\n# Extender\n\n`extender` is a library that helps in making chainable APIs, by creating a function that accepts different values and returns an object decorated with functions based on the type.\n\n## Why Is Extender Different?\n\nExtender is different than normal chaining because is does more than return `this`. It decorates your values in a type safe manner.\n\nFor example if you return an array from a string based method then the returned value will be decorated with array methods and not the string methods. This allow you as the developer to focus on your API and not worrying about how to properly build and connect your API.\n\n\n## Installation\n\n```\nnpm install extender\n```\n\nOr [download the source](https://raw.github.com/doug-martin/extender/master/extender.js) ([minified](https://raw.github.com/doug-martin/extender/master/extender-min.js))\n\n**Note** `extender` depends on [`declare.js`](http://doug-martin.github.com/declare.js/).\n\n### Requirejs\n\nTo use with requirejs place the `extend` source in the root scripts directory\n\n```javascript\n\ndefine([\"extender\"], function(extender){\n});\n\n```\n\n\n## Usage\n\n**`extender.define(tester, decorations)`**\n\nTo create your own extender call the `extender.define` function.\n\nThis function accepts an optional tester which is used to determine a value should be decorated with the specified `decorations`\n\n```javascript\nfunction isString(obj) {\n    return !isUndefinedOrNull(obj) && (typeof obj === \"string\" || obj instanceof String);\n}\n\n\nvar myExtender = extender.define(isString, {\n\tmultiply: function (str, times) {\n\t\tvar ret = str;\n\t\tfor (var i = 1; i < times; i++) {\n\t\t\tret += str;\n\t\t}\n\t\treturn ret;\n\t},\n\ttoArray: function (str, delim) {\n\t\tdelim = delim || \"\";\n\t\treturn str.split(delim);\n\t}\n});\n\nmyExtender(\"hello\").multiply(2).value(); //hellohello\n\n```\n\nIf you do not specify a tester function and just pass in an object of `functions` then all values passed in will be decorated with methods.\n\n```javascript\n\nfunction isUndefined(obj) {\n    var undef;\n    return obj === undef;\n}\n\nfunction isUndefinedOrNull(obj) {\nvar undef;\n    return obj === undef || obj === null;\n}\n\nfunction isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n}\n\nfunction isBoolean(obj) {\n    var undef, type = typeof obj;\n    return !isUndefinedOrNull(obj) && type === \"boolean\" || type === \"Boolean\";\n}\n\nfunction isString(obj) {\n    return !isUndefinedOrNull(obj) && (typeof obj === \"string\" || obj instanceof String);\n}\n\nvar myExtender = extender.define({\nisUndefined : isUndefined,\nisUndefinedOrNull : isUndefinedOrNull,\nisArray : isArray,\nisBoolean : isBoolean,\nisString : isString\n});\n\n```\n\nTo use\n\n```\nvar undef;\nmyExtender(\"hello\").isUndefined().value(); //false\nmyExtender(undef).isUndefined().value(); //true\n```\n\nYou can also chain extenders so that they accept multiple types and decorates accordingly.\n\n```javascript\nmyExtender\n    .define(isArray, {\n\tpluck: function (arr, m) {\n\t\tvar ret = [];\n\t\tfor (var i = 0, l = arr.length; i < l; i++) {\n\t\t\tret.push(arr[i][m]);\n\t\t}\n\t\treturn ret;\n\t}\n})\n    .define(isBoolean, {\n\tinvert: function (val) {\n\t\treturn !val;\n\t}\n});\n\nmyExtender([{a: \"a\"},{a: \"b\"},{a: \"c\"}]).pluck(\"a\").value(); //[\"a\", \"b\", \"c\"]\nmyExtender(\"I love javascript!\").toArray(/\\s+/).pluck(\"0\"); //[\"I\", \"l\", \"j\"]\n\n```\n\nNotice that we reuse the same extender as defined above.\n\n**Return Values**\n\nWhen creating an extender if you return a value from one of the decoration functions then that value will also be decorated. If you do not return any values then the extender will be returned.\n\n**Default decoration methods**\n\nBy default every value passed into an extender is decorated with the following methods.\n\n* `value` : The value this extender represents.\n* `eq(otherValue)` : Tests strict equality of the currently represented value to the `otherValue`\n* `neq(oterValue)` : Tests strict inequality of the currently represented value.\n* `print` : logs the current value to the console.\n\n**Extender initialization**\n\nWhen creating an extender you can also specify a constructor which will be invoked with the current value.\n\n```javascript\nmyExtender.define(isString, {\nconstructor : function(val){\n    //set our value to the string trimmed\n\tthis._value = val.trimRight().trimLeft();\n}\n});\n```\n\n**`noWrap`**\n\n`extender` also allows you to specify methods that should not have the value wrapped providing a cleaner exit function other than `value()`.\n\nFor example suppose you have an API that allows you to build a validator, rather than forcing the user to invoke the `value` method you could add a method called `validator` which makes more syntactic sense.\n\n```\n\nvar myValidator = extender.define({\n    //chainable validation methods\n    //...\n    //end chainable validation methods\n\n    noWrap : {\n        validator : function(){\n            //return your validator\n        }\n    }\n});\n\nmyValidator().isNotNull().isEmailAddress().validator(); //now you dont need to call .value()\n\n\n```\n**`extender.extend(extendr)`**\n\nYou may also compose extenders through the use of `extender.extend(extender)`, which will return an entirely new extender that is the composition of extenders.\n\nSuppose you have the following two extenders.\n\n```javascript\nvar myExtender = extender\n       .define({\n           isFunction: is.function,\n           isNumber: is.number,\n           isString: is.string,\n           isDate: is.date,\n           isArray: is.array,\n           isBoolean: is.boolean,\n           isUndefined: is.undefined,\n           isDefined: is.defined,\n           isUndefinedOrNull: is.undefinedOrNull,\n           isNull: is.null,\n           isArguments: is.arguments,\n           isInstanceOf: is.instanceOf,\n           isRegExp: is.regExp\n       });\nvar myExtender2 = extender.define(is.array, {\n    pluck: function (arr, m) {\n        var ret = [];\n        for (var i = 0, l = arr.length; i < l; i++) {\n            ret.push(arr[i][m]);\n        }\n        return ret;\n    },\n\n    noWrap: {\n        pluckPlain: function (arr, m) {\n            var ret = [];\n            for (var i = 0, l = arr.length; i < l; i++) {\n                ret.push(arr[i][m]);\n            }\n            return ret;\n        }\n    }\n});\n\n\n```\n\nAnd you do not want to alter either of them but instead what to create a third that is the union of the two.\n\n\n```javascript\nvar composed = extender.extend(myExtender).extend(myExtender2);\n```\nSo now you can use the new extender with the joined functionality if `myExtender` and `myExtender2`.\n\n```javascript\nvar extended = composed([\n     {a: \"a\"},\n     {a: \"b\"},\n     {a: \"c\"}\n]);\nextended.isArray().value(); //true\nextended.pluck(\"a\").value(); // [\"a\", \"b\", \"c\"]);\n\n```\n\n**Note** `myExtender` and `myExtender2` will **NOT** be altered.\n\n**`extender.expose(methods)`**\n\nThe `expose` method allows you to add methods to your extender that are not wrapped or automatically chained by exposing them on the extender directly.\n\n```\nvar isMethods = {\n     isFunction: is.function,\n     isNumber: is.number,\n     isString: is.string,\n     isDate: is.date,\n     isArray: is.array,\n     isBoolean: is.boolean,\n     isUndefined: is.undefined,\n     isDefined: is.defined,\n     isUndefinedOrNull: is.undefinedOrNull,\n     isNull: is.null,\n     isArguments: is.arguments,\n     isInstanceOf: is.instanceOf,\n     isRegExp: is.regExp\n};\n\nvar myExtender = extender.define(isMethods).expose(isMethods);\n\nmyExtender.isArray([]); //true\nmyExtender([]).isArray([]).value(); //true\n\n```\n\n\n**Using `instanceof`**\n\nWhen using extenders you can test if a value is an `instanceof` of an extender by using the instanceof operator.\n\n```javascript\nvar str = myExtender(\"hello\");\n\nstr instanceof myExtender; //true\n```\n\n## Examples\n\nTo see more examples click [here](https://github.com/doug-martin/extender/tree/master/examples)\n\n\n\n\n\n\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "extender@0.0.9",
  "dist": {
    "shasum": "39a32da76ef50cf81a03e2914d632d4fbf118f6b"
  },
  "_from": "extender@~0.0.5",
  "_resolved": "https://registry.npmjs.org/extender/-/extender-0.0.9.tgz"
}
