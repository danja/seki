{
  "name": "promise-extended",
  "version": "0.0.8",
  "description": "Promises implementation with chainable API",
  "main": "index.js",
  "scripts": {
    "test": "it -r dot"
  },
  "repository": {
    "type": "git",
    "url": "git:git@github.com:doug-martin/promise-extended.git"
  },
  "keywords": [
    "Promise",
    "extender",
    "utilities"
  ],
  "testling": {
    "files": "test/browserling.js",
    "browsers": [
      "ie/8..latest",
      "chrome/20..latest",
      "firefox/14..latest",
      "safari/latest",
      "iphone/6",
      "ipad/6"
    ]
  },
  "author": {
    "name": "Doug Martin"
  },
  "license": "MIT",
  "dependencies": {
    "extended": "~0.0.3",
    "is-extended": "~0.0.3",
    "array-extended": "~0.0.3",
    "function-extended": "~0.0.3",
    "arguments-extended": "~0.0.3",
    "grunt": "~0.4.1",
    "declare.js": "~0.0.3",
    "grunt-contrib-jshint": "~0.3.0"
  },
  "devDependencies": {
    "it": "~0.2.0",
    "grunt-it": "~0.3.0",
    "promises-aplus-tests": "*",
    "grunt-contrib-uglify": "~0.2.0"
  },
  "readme": "[![Build Status](https://travis-ci.org/doug-martin/promise-extended.png?branch=master)](undefined)\n\n[![browser support](https://ci.testling.com/doug-martin/promise-extended.png)](https://ci.testling.com/doug-martin/promise-extended)\n\n# promise-extended\n\n`promise-extended` is a Javascript library that can be used standalone or incorporated into [`extended`](https://github.com/doug-martin/extended)\n\n```javascript\nvar promise = require(\"promise-extended\");\n```\n\nOr\n\n```javascript\nvar myextended = require(\"extended\")\n\t.register(require(\"promise-extended\"));\n```\n\n## Installation\n\n```\nnpm install promise-extended\n```\n\nOr [download the source](https://raw.github.com/doug-martin/promise-extended/master/index.js) ([minified](https://raw.github.com/doug-martin/promise-extended/master/promise-extended.min.js))\n\n## Usage\n\n**`Promise`**\n\nThe promise constructor used by `promise` and `defer`\n\n**`Promise#callback`**\n\nResolve a promise with the given value.\n\n**`Promise#errback`**\n\nReject a promise with the given value.\n\n**`Promise#callback`**\n\nResolve a promise with the given value.\n\n**`Promise#then(callback[, errback)`**\n\nAllows the chaining of promises.\n\n```\nfunction myAsyncAction(num){\n    var p = new promise.Promise();\n    setTimeout(funciton(){\n        p.callback(num);\n    }, 50);\n    return p.promise();\n}\n\nmyAsyncAction(1)\n    .then(function(num){\n        return myAsyncAction(num+1);\n    })\n    .then(function(num){\n        return myAsyncAction(num+1);\n    })\n    .then(function(num){\n        console.log(num); //3\n    });\n\n```\n\nErrors are propagated the the nearest error handler, this allows the bubbling of errors up a chain of promises.\n\n```\nfunction myAsyncAction(num){\n    var p = new promise.Promise();\n    setTimeout(funciton(){\n        p.callback(num);\n    }, 50);\n    return p.promise();\n}\n\nmyAsyncAction(1)\n    .then(function(num){\n        throw new Error(\"oops an error occured\");\n    })\n    .then(function(num){\n        return myAsyncAction(num+1);\n    })\n    .then(\n        function(num){\n            console.log(num); //3\n        },\n        function(err){\n            console.log(err); //oops an error occured.\n        }\n    );\n\n```\n\nOf you return a promise from an error handler that resolved successfully then the next promise is the chain will be resolved successfully.\n\n```\nfunction myAsyncAction(num){\n    var p = new promise.Promise();\n    setTimeout(funciton(){\n        p.callback(num);\n    }, 50);\n    return p.promise();\n}\n\nmyAsyncAction(1)\n    .then(function(num){\n        throw new Error(\"oops an error occured\");\n    })\n    .then(function(num){\n        return myAsyncAction(num+1);\n    })\n    .then(\n        function(num){\n            console.log(num); //3\n        },\n        function(err){\n            console.log(err); //oops an error occured.\n            return asyncAction(10);\n        }\n    )\n    .then(function(num){\n        console.log(num); //10\n    });\n\n```\n\n**`Promise#both`**\n\nAllows the execution of a function regardless of whether or not a promises is successful.\n\n```\n\nnew promise.Promise().errback(\"error\").both(function(){\n    //do some more work\n}).then(function(){\n\n});\n\n```\n\n**`Promise#resolve`**\n\nThe resolve method provides a mechanism to work with node style callbacks and promises.\n\n```javascript\n\nvar fs = require(\"fs\");\n\nvar myPromise = new promise.Promise();\nfs.readFile(__dirname + \"/myFile.txt\", \"utf8\", myPromise.resolve);\n\nmyPromise.then(function(txt){\n    console.log(txt);\n});\n\n```\n\n**`Promise#classic`**\n\nAccepts a callback in the typical node style.\n\n```\n\nnew promise.Promise()\n    .callback(\"hello\")\n    .classic(function(err, res){\n        console.log(res); //\"hello\"\n    });\n\n```\n\n**`isPromiseLike`**\n\nDetermines if an object is like a promise (contains a `.then` function).\n\n```javascript\n\npromise.isPromiseLike({then : function(){}}); //true\npromise({then : function(){}}).isPromiseLike(); //true\n\n```\n\n\n**`promise`**\n\nCreates a new promise.\n\n```javascript\nfunction myAsyncAction(){\n    var p = promise.promise();\n    setTimeout(funciton(){\n        p.callback(\"hello\");\n    }, 50);\n    return p.promise();\n}\n\nmyAsyncAction().then(function(hello){\n    console.log(hello);\n});\n\n```\n\n**`promiseList`**\n\nCreates a new promise.\n\n```javascript\nfunction myAsyncAction(){\n    var p = promise.promise();\n    setTimeout(funciton(){\n        p.callback(\"hello\");\n    }, 50);\n    return p.promise();\n}\n\npromise.promiseList([myAsyncAction(), myAsyncAction()]).then(function(hello){\n    console.log(hello); //[\"hello\", \"hello\"]\n});\n\n```\n\n**`defer`**\n\nCreates a new promise.\n\n```javascript\nfunction myAsyncAction(){\n    var p = promise.defer();\n    setTimeout(funciton(){\n        p.callback(\"hello\");\n    }, 50);\n    return p.promise();\n}\n\nmyAsyncAction.then(function(hello){\n    console.log(hello);\n});\n\n```\n\n**`deferredList`**\n\nCreates a new promise.\n\n```javascript\nfunction myAsyncAction(){\n    var p = promise.defer();\n    setTimeout(funciton(){\n        p.callback(\"hello\");\n    }, 50);\n    return p.promise();\n}\n\npromise.deferredList([myAsyncAction(), myAsyncAction()]).then(function(hello){\n    console.log(hello); //[\"hello\", \"hello\"]\n});\n\n```\n\n**`resolve`**\n\nCreates a promise that is resolved with the provided value.\n\n```javascript\n\npromise.resolve(\"hello\")\n    .then(function(hello){\n        console.log(hello); //hello\n    });\n\n```\n\n**`reject`**\n\nCreates a promise that is errored with the provided value.\n\n```javascript\n\npromise.reject(new Error(\"an error occured\"))\n    .then(function(){\n        //not called\n    }, function(err){\n       console.log(err.stack);\n    });\n\n```\n\n\n**`wrap`**\n\nWraps traditional node style functions with a promise.\n\n```javascript\n\nvar fs = require(\"fs\");\nvar readFile = promise.wrap(fs.readFile, fs);\nreadFile(__dirname + \"/test.json\").then(\n    function(buffer){\n        console.log(contents);\n    },\n    function(err){\n       console.error(err);\n    }\n);\n```\n\n**`serial`**\n\nExecutes a list of items in a serial manner.\n\nIf the list contains promises then each promise will be executed in a serial manner.\n\nIf the list contains non async items then the next item in the list is called.\n\n**Note** This will not propogate values from one action to another, instead results are passed as an array to the eventual promise.\n\n```javascript\n\nfunction asyncAction(item, timeout){\n    return function(){\n        var p = promise.promise();\n        setTimeout(function(){\n            return p.callback(item);\n        }, timeout);\n        return p.promise();\n    }\n};\n\npromise.serial([\n    asyncAction(1, 1000),\n    asyncAction(2, 900),\n    asyncAction(3, 800),\n    asyncAction(4, 700),\n    asyncAction(5, 600),\n    asyncAction(6, 500),\n    asyncAction(7, 400),\n    asyncAction(8, 300),\n    asyncAction(9, 200),\n]).then(function(results){\n    console.log(results); // [1,2,3,4,5,6,7,8, 9];\n});\n\n```\n\n\n**`chain`**\n\nAllows you to propogate results from one function to another.\n\nThis is different than `.serial` in that it propogates results from one promise to the next, where `.serial` does not.\n\n```javascript\n\nfunction asyncAction(add, timeout) {\n\n     return function (num) {\n         num = num || 0;\n         var p = promise.promise();\n         setTimeout(function () {\n              p.callback(num + add);\n         }, timeout);\n         return p.promise();;\n     }\n}\n\npromise.chain([\n     asyncAction(1, 100),\n     asyncAction(2, 100),\n     asyncAction(3, 100),\n     asyncAction(4, 100),\n     asyncAction(5, 100),\n]).then(function(results){\n     console.log(results); //15\n});\n\n```\n\n**`wait`**\n\nEnsures that a promise is resolved before a the function can be run.\n\nFor example suppose you have to ensure that you are connected to a database before you execute a function.\n\n```\nvar findUser = promise.wait(connect(), function findUser(id){\n     //this wont execute until we are connected\n     return User.findById(id);\n});\n\npromise.when(findUser(1), findUser(2)).then(function(users){\n    var user1 = users[0], user2 = users[1];\n });\n\n```\n",
  "readmeFilename": "README.md",
  "_id": "promise-extended@0.0.8",
  "dist": {
    "shasum": "6c2406d15e91944d8b9ed98302a4a31185fc8473"
  },
  "_from": "promise-extended@~0.0.3",
  "_resolved": "https://registry.npmjs.org/promise-extended/-/promise-extended-0.0.8.tgz"
}
